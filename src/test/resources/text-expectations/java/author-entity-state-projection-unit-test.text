package io.vlingo.xoomapp.infrastructure.persistence;

import io.vlingo.xoom.actors.World;
import io.vlingo.xoom.actors.testkit.AccessSafely;
import io.vlingo.xoom.common.serialization.JsonSerialization;
import io.vlingo.xoom.lattice.model.projection.Projectable;
import io.vlingo.xoom.lattice.model.projection.Projection;
import io.vlingo.xoom.lattice.model.projection.TextProjectable;
import io.vlingo.xoom.lattice.model.stateful.StatefulTypeRegistry;
import io.vlingo.xoom.symbio.Metadata;
import io.vlingo.xoom.symbio.State.TextState;
import io.vlingo.xoom.symbio.store.dispatch.NoOpDispatcher;
import io.vlingo.xoom.symbio.store.state.StateStore;
import io.vlingo.xoom.symbio.store.state.inmemory.InMemoryStateStoreActor;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.*;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

import java.time.LocalDate;
import io.vlingo.xoomapp.infrastructure.*;
import java.util.*;
import io.vlingo.xoomapp.model.author.*;
public class AuthorProjectionTest {
  private Projection projection;
  private StateStore store;
  private Map<String,String> valueToProjectionId;
  private World world;

  @BeforeEach
  public void setUp() {
    world = World.startWithDefaults("test-state-store-projection");

    store = world.actorFor(StateStore.class, InMemoryStateStoreActor.class, Arrays.asList(new NoOpDispatcher()));

    projection = world.actorFor(Projection.class, AuthorProjectionActor.class, store);

    StatefulTypeRegistry.registerAll(world, store, AuthorData.class);

    valueToProjectionId = new HashMap<>();
  }
  @Test
  public void withName() {
    final CountingProjectionControl control = new CountingProjectionControl();
    final AccessSafely access = control.afterCompleting(3);

    projection.projectWith(createAuthorRegistered("1", 1, "AuthorRegistered"), control);
    projection.projectWith(createAuthorRegistered("2", 2, "AuthorRegistered"), control);
    projection.projectWith(createAuthorRegistered("3", 3, "AuthorRegistered"), control);

    final Map<String,Integer> confirmations = access.readFrom("confirmations");

    assertEquals(3, confirmations.size());

    assertEquals(1, valueOfProjectionIdFor("1", confirmations));
    assertEquals(1, valueOfProjectionIdFor("2", confirmations));
    assertEquals(1, valueOfProjectionIdFor("3", confirmations));

		assertEquals(3, ((Map) access.readFrom("confirmations")).size());
  }
	private Projectable createAuthorRegistered(final String id, final int value, final String operation) {
		final String valueText = Integer.toString(value);
	    final AuthorData firstData = AuthorData.from("1", NameData.from("first-author-name-firstName", "first-author-name-lastName"), new ArrayList<>(), LocalDate.now(), new ArrayList<>(), new HashSet<>());

		final TextState state = new TextState(id, AuthorState.class, 1, JsonSerialization.serialized(firstData.toAuthorState()), 1,
		Metadata.with(firstData.toAuthorState(), valueText, operation));
		final String projectionId = UUID.randomUUID().toString();

		valueToProjectionId.put(valueText, projectionId);

		return new TextProjectable(state, Collections.emptyList(), projectionId);
	}

  @Test
  public void changeRank() {
    final CountingProjectionControl control = new CountingProjectionControl();
    final AccessSafely access = control.afterCompleting(3);

    projection.projectWith(createAuthorRanked("1", 1, "AuthorRanked"), control);
    projection.projectWith(createAuthorRanked("2", 2, "AuthorRanked"), control);
    projection.projectWith(createAuthorRanked("3", 3, "AuthorRanked"), control);

    final Map<String,Integer> confirmations = access.readFrom("confirmations");

    assertEquals(3, confirmations.size());

    assertEquals(1, valueOfProjectionIdFor("1", confirmations));
    assertEquals(1, valueOfProjectionIdFor("2", confirmations));
    assertEquals(1, valueOfProjectionIdFor("3", confirmations));

		assertEquals(3, ((Map) access.readFrom("confirmations")).size());
  }
	private Projectable createAuthorRanked(final String id, final int value, final String operation) {
		final String valueText = Integer.toString(value);
	    final AuthorData firstData = AuthorData.from("1", NameData.from("first-author-name-firstName", "first-author-name-lastName"), new ArrayList<>(), LocalDate.now(), new ArrayList<>(), new HashSet<>());

		final TextState state = new TextState(id, AuthorState.class, 1, JsonSerialization.serialized(firstData.toAuthorState()), 1,
		Metadata.with(firstData.toAuthorState(), valueText, operation));
		final String projectionId = UUID.randomUUID().toString();

		valueToProjectionId.put(valueText, projectionId);

		return new TextProjectable(state, Collections.emptyList(), projectionId);
	}

  @Test
  public void addTag() {
    final CountingProjectionControl control = new CountingProjectionControl();
    final AccessSafely access = control.afterCompleting(3);

    projection.projectWith(createAuthorTagged("1", 1, "AuthorTagged"), control);
    projection.projectWith(createAuthorTagged("2", 2, "AuthorTagged"), control);
    projection.projectWith(createAuthorTagged("3", 3, "AuthorTagged"), control);

    final Map<String,Integer> confirmations = access.readFrom("confirmations");

    assertEquals(3, confirmations.size());

    assertEquals(1, valueOfProjectionIdFor("1", confirmations));
    assertEquals(1, valueOfProjectionIdFor("2", confirmations));
    assertEquals(1, valueOfProjectionIdFor("3", confirmations));

		assertEquals(3, ((Map) access.readFrom("confirmations")).size());
  }
	private Projectable createAuthorTagged(final String id, final int value, final String operation) {
		final String valueText = Integer.toString(value);
	    final AuthorData firstData = AuthorData.from("1", NameData.from("first-author-name-firstName", "first-author-name-lastName"), new ArrayList<>(), LocalDate.now(), new ArrayList<>(), new HashSet<>());

		final TextState state = new TextState(id, AuthorState.class, 1, JsonSerialization.serialized(firstData.toAuthorState()), 1,
		Metadata.with(firstData.toAuthorState(), valueText, operation));
		final String projectionId = UUID.randomUUID().toString();

		valueToProjectionId.put(valueText, projectionId);

		return new TextProjectable(state, Collections.emptyList(), projectionId);
	}

  @Test
  public void addTags() {
    final CountingProjectionControl control = new CountingProjectionControl();
    final AccessSafely access = control.afterCompleting(3);

    projection.projectWith(createAuthorBulkTagged("1", 1, "AuthorBulkTagged"), control);
    projection.projectWith(createAuthorBulkTagged("2", 2, "AuthorBulkTagged"), control);
    projection.projectWith(createAuthorBulkTagged("3", 3, "AuthorBulkTagged"), control);

    final Map<String,Integer> confirmations = access.readFrom("confirmations");

    assertEquals(3, confirmations.size());

    assertEquals(1, valueOfProjectionIdFor("1", confirmations));
    assertEquals(1, valueOfProjectionIdFor("2", confirmations));
    assertEquals(1, valueOfProjectionIdFor("3", confirmations));

		assertEquals(3, ((Map) access.readFrom("confirmations")).size());
  }
	private Projectable createAuthorBulkTagged(final String id, final int value, final String operation) {
		final String valueText = Integer.toString(value);
	    final AuthorData firstData = AuthorData.from("1", NameData.from("first-author-name-firstName", "first-author-name-lastName"), new ArrayList<>(), LocalDate.now(), new ArrayList<>(), new HashSet<>());

		final TextState state = new TextState(id, AuthorState.class, 1, JsonSerialization.serialized(firstData.toAuthorState()), 1,
		Metadata.with(firstData.toAuthorState(), valueText, operation));
		final String projectionId = UUID.randomUUID().toString();

		valueToProjectionId.put(valueText, projectionId);

		return new TextProjectable(state, Collections.emptyList(), projectionId);
	}

  @Test
  public void replaceTags() {
    final CountingProjectionControl control = new CountingProjectionControl();
    final AccessSafely access = control.afterCompleting(3);

    projection.projectWith(createAuthorTagsReplacedEvent("1", 1, "AuthorTagsReplacedEvent"), control);
    projection.projectWith(createAuthorTagsReplacedEvent("2", 2, "AuthorTagsReplacedEvent"), control);
    projection.projectWith(createAuthorTagsReplacedEvent("3", 3, "AuthorTagsReplacedEvent"), control);

    final Map<String,Integer> confirmations = access.readFrom("confirmations");

    assertEquals(3, confirmations.size());

    assertEquals(1, valueOfProjectionIdFor("1", confirmations));
    assertEquals(1, valueOfProjectionIdFor("2", confirmations));
    assertEquals(1, valueOfProjectionIdFor("3", confirmations));

		assertEquals(3, ((Map) access.readFrom("confirmations")).size());
  }
	private Projectable createAuthorTagsReplacedEvent(final String id, final int value, final String operation) {
		final String valueText = Integer.toString(value);
	    final AuthorData firstData = AuthorData.from("1", NameData.from("first-author-name-firstName", "first-author-name-lastName"), new ArrayList<>(), LocalDate.now(), new ArrayList<>(), new HashSet<>());

		final TextState state = new TextState(id, AuthorState.class, 1, JsonSerialization.serialized(firstData.toAuthorState()), 1,
		Metadata.with(firstData.toAuthorState(), valueText, operation));
		final String projectionId = UUID.randomUUID().toString();

		valueToProjectionId.put(valueText, projectionId);

		return new TextProjectable(state, Collections.emptyList(), projectionId);
	}

  @Test
  public void removeTag() {
    final CountingProjectionControl control = new CountingProjectionControl();
    final AccessSafely access = control.afterCompleting(3);

    projection.projectWith(createAuthorUntagged("1", 1, "AuthorUntagged"), control);
    projection.projectWith(createAuthorUntagged("2", 2, "AuthorUntagged"), control);
    projection.projectWith(createAuthorUntagged("3", 3, "AuthorUntagged"), control);

    final Map<String,Integer> confirmations = access.readFrom("confirmations");

    assertEquals(3, confirmations.size());

    assertEquals(1, valueOfProjectionIdFor("1", confirmations));
    assertEquals(1, valueOfProjectionIdFor("2", confirmations));
    assertEquals(1, valueOfProjectionIdFor("3", confirmations));

		assertEquals(3, ((Map) access.readFrom("confirmations")).size());
  }
	private Projectable createAuthorUntagged(final String id, final int value, final String operation) {
		final String valueText = Integer.toString(value);
	    final AuthorData firstData = AuthorData.from("1", NameData.from("first-author-name-firstName", "first-author-name-lastName"), new ArrayList<>(), LocalDate.now(), new ArrayList<>(), new HashSet<>());

		final TextState state = new TextState(id, AuthorState.class, 1, JsonSerialization.serialized(firstData.toAuthorState()), 1,
		Metadata.with(firstData.toAuthorState(), valueText, operation));
		final String projectionId = UUID.randomUUID().toString();

		valueToProjectionId.put(valueText, projectionId);

		return new TextProjectable(state, Collections.emptyList(), projectionId);
	}

  @Test
  public void relateAuthor() {
    final CountingProjectionControl control = new CountingProjectionControl();
    final AccessSafely access = control.afterCompleting(3);

    projection.projectWith(createAuthorRelated("1", 1, "AuthorRelated"), control);
    projection.projectWith(createAuthorRelated("2", 2, "AuthorRelated"), control);
    projection.projectWith(createAuthorRelated("3", 3, "AuthorRelated"), control);

    final Map<String,Integer> confirmations = access.readFrom("confirmations");

    assertEquals(3, confirmations.size());

    assertEquals(1, valueOfProjectionIdFor("1", confirmations));
    assertEquals(1, valueOfProjectionIdFor("2", confirmations));
    assertEquals(1, valueOfProjectionIdFor("3", confirmations));

		assertEquals(3, ((Map) access.readFrom("confirmations")).size());
  }
	private Projectable createAuthorRelated(final String id, final int value, final String operation) {
		final String valueText = Integer.toString(value);
	    final AuthorData firstData = AuthorData.from("1", NameData.from("first-author-name-firstName", "first-author-name-lastName"), new ArrayList<>(), LocalDate.now(), new ArrayList<>(), new HashSet<>());

		final TextState state = new TextState(id, AuthorState.class, 1, JsonSerialization.serialized(firstData.toAuthorState()), 1,
		Metadata.with(firstData.toAuthorState(), valueText, operation));
		final String projectionId = UUID.randomUUID().toString();

		valueToProjectionId.put(valueText, projectionId);

		return new TextProjectable(state, Collections.emptyList(), projectionId);
	}

  @Test
  public void relateAuthors() {
    final CountingProjectionControl control = new CountingProjectionControl();
    final AccessSafely access = control.afterCompleting(3);

    projection.projectWith(createAuthorsRelated("1", 1, "AuthorsRelated"), control);
    projection.projectWith(createAuthorsRelated("2", 2, "AuthorsRelated"), control);
    projection.projectWith(createAuthorsRelated("3", 3, "AuthorsRelated"), control);

    final Map<String,Integer> confirmations = access.readFrom("confirmations");

    assertEquals(3, confirmations.size());

    assertEquals(1, valueOfProjectionIdFor("1", confirmations));
    assertEquals(1, valueOfProjectionIdFor("2", confirmations));
    assertEquals(1, valueOfProjectionIdFor("3", confirmations));

		assertEquals(3, ((Map) access.readFrom("confirmations")).size());
  }
	private Projectable createAuthorsRelated(final String id, final int value, final String operation) {
		final String valueText = Integer.toString(value);
	    final AuthorData firstData = AuthorData.from("1", NameData.from("first-author-name-firstName", "first-author-name-lastName"), new ArrayList<>(), LocalDate.now(), new ArrayList<>(), new HashSet<>());

		final TextState state = new TextState(id, AuthorState.class, 1, JsonSerialization.serialized(firstData.toAuthorState()), 1,
		Metadata.with(firstData.toAuthorState(), valueText, operation));
		final String projectionId = UUID.randomUUID().toString();

		valueToProjectionId.put(valueText, projectionId);

		return new TextProjectable(state, Collections.emptyList(), projectionId);
	}

  @Test
  public void unrelateAuthor() {
    final CountingProjectionControl control = new CountingProjectionControl();
    final AccessSafely access = control.afterCompleting(3);

    projection.projectWith(createAuthorUnrelated("1", 1, "AuthorUnrelated"), control);
    projection.projectWith(createAuthorUnrelated("2", 2, "AuthorUnrelated"), control);
    projection.projectWith(createAuthorUnrelated("3", 3, "AuthorUnrelated"), control);

    final Map<String,Integer> confirmations = access.readFrom("confirmations");

    assertEquals(3, confirmations.size());

    assertEquals(1, valueOfProjectionIdFor("1", confirmations));
    assertEquals(1, valueOfProjectionIdFor("2", confirmations));
    assertEquals(1, valueOfProjectionIdFor("3", confirmations));

		assertEquals(3, ((Map) access.readFrom("confirmations")).size());
  }
	private Projectable createAuthorUnrelated(final String id, final int value, final String operation) {
		final String valueText = Integer.toString(value);
	    final AuthorData firstData = AuthorData.from("1", NameData.from("first-author-name-firstName", "first-author-name-lastName"), new ArrayList<>(), LocalDate.now(), new ArrayList<>(), new HashSet<>());

		final TextState state = new TextState(id, AuthorState.class, 1, JsonSerialization.serialized(firstData.toAuthorState()), 1,
		Metadata.with(firstData.toAuthorState(), valueText, operation));
		final String projectionId = UUID.randomUUID().toString();

		valueToProjectionId.put(valueText, projectionId);

		return new TextProjectable(state, Collections.emptyList(), projectionId);
	}

  @Test
  public void replaceAllRelatedAuthors() {
    final CountingProjectionControl control = new CountingProjectionControl();
    final AccessSafely access = control.afterCompleting(3);

    projection.projectWith(createRelatedAuthorsReplacedEvent("1", 1, "RelatedAuthorsReplacedEvent"), control);
    projection.projectWith(createRelatedAuthorsReplacedEvent("2", 2, "RelatedAuthorsReplacedEvent"), control);
    projection.projectWith(createRelatedAuthorsReplacedEvent("3", 3, "RelatedAuthorsReplacedEvent"), control);

    final Map<String,Integer> confirmations = access.readFrom("confirmations");

    assertEquals(3, confirmations.size());

    assertEquals(1, valueOfProjectionIdFor("1", confirmations));
    assertEquals(1, valueOfProjectionIdFor("2", confirmations));
    assertEquals(1, valueOfProjectionIdFor("3", confirmations));

		assertEquals(3, ((Map) access.readFrom("confirmations")).size());
  }
	private Projectable createRelatedAuthorsReplacedEvent(final String id, final int value, final String operation) {
		final String valueText = Integer.toString(value);
	    final AuthorData firstData = AuthorData.from("1", NameData.from("first-author-name-firstName", "first-author-name-lastName"), new ArrayList<>(), LocalDate.now(), new ArrayList<>(), new HashSet<>());

		final TextState state = new TextState(id, AuthorState.class, 1, JsonSerialization.serialized(firstData.toAuthorState()), 1,
		Metadata.with(firstData.toAuthorState(), valueText, operation));
		final String projectionId = UUID.randomUUID().toString();

		valueToProjectionId.put(valueText, projectionId);

		return new TextProjectable(state, Collections.emptyList(), projectionId);
	}


  @AfterEach
  public void tearDown() {
    world.terminate();
  }

  private int valueOfProjectionIdFor(final String valueText, final Map<String,Integer> confirmations) {
    return confirmations.get(valueToProjectionId.get(valueText));
  }

}
